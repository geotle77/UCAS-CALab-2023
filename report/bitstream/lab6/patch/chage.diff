diff --git a/BUS_LEN.vh b/BUS_LEN.vh
index 7746868..1c186d9 100644
--- a/BUS_LEN.vh
+++ b/BUS_LEN.vh
@@ -1,46 +1,16 @@
 `ifndef BUS_LEN
-    `define BUS_LEN
 
-    `define FS2DS_BUS_LEN 64  //fs_pc, inst
-    `define FORWARD_BUS_LEN 38
-    `define DS2ES_BUS_LEN 244 //es_pc, alu_src1, alu_src2, alu_op,load_op,store_op, rkd_value, gr_we, dest, mem_we,except_zip
-    `define ES2MS_BUS_LEN 160//ms_pc, mul_op,mem_gr_we, mem_dest, final_result,except_zip
-    `define MS2WS_BUS_LEN 152
-    `define WS2CSR_BUS_LEN 127
+    `define BR_BUS        33
+    `define FS2DS_BUS_LEN 97  //fs_exc_data, fs_pc, inst
+    `define DS2ES_BUS_LEN 262 //es_pc, alu_src1, alu_src2, alu_op,load_op,store_op, rkd_value, gr_we, dest, mem_we,ds_exc_data, time_op
+    `define ES2MS_BUS_LEN 208  //ms_pc, mul_op,mem_gr_we, mem_dest, final_result,es_rl_value, es_exc_date
+    `define MS2WS_BUS_LEN 199
     
     `define FORWARD_BUS_LEN 38
-    
-    `define EXCEPT_LEN 82
-    `define ALU_OP_LEN 19
-    `define WB_RF_BUS 38
-    `define BR_BUS 33
-    
-    
-        `define CSR_CRMD   14'h00
-    `define CSR_PRMD   14'h01
-    `define CSR_EUEN   14'h02
-    `define CSR_ECFG   14'h04
-    `define CSR_ESTAT  14'h05
-    `define CSR_ERA    14'h06
-    `define CSR_BADV   14'h07
-    `define CSR_EENTRY 14'h0c
-    `define CSR_SAVE0  14'h30
-    `define CSR_SAVE1  14'h31
-    `define CSR_SAVE2  14'h32
-    `define CSR_SAVE3  14'h33
-    `define CSR_TID    14'h40
-    `define CSR_TCFG   14'h41
-    `define CSR_TVAL   14'h42
-    `define CSR_TICLR  14'h44
+    `define WS_TO_FS_CSR_DATA_LEN 200
+    `define FS_EXC_DATA_WD  33
+    `define DS_EXC_DATA_WD  98
+    `define ES_EXC_DATA_WD  97
+    `define MS_EXC_DATA_WD  97
 
-    `define CSR_CRMD_PLV    1 :0
-    `define CSR_CRMD_IE     2
-    `define CSR_PRMD_PPLV   1 :0
-    `define CSR_PRMD_PIE    2
-    `define CSR_ECFG_LIE    12:0
-    `define CSR_ESTAT_IS10  1 :0
-    `define CSR_ERA_PC      31:0
-    `define CSR_EENTRY_VA   31:6
-    `define CSR_SAVE_DATA   31:0
-    `define CSR_TID_TID     31:0
 `endif
\ No newline at end of file
diff --git a/EXEstage.v b/EXEstage.v
index 1e15791..f0e4f9f 100644
--- a/EXEstage.v
+++ b/EXEstage.v
@@ -1,4 +1,5 @@
 `include "BUS_LEN.vh"
+`include "CSR.vh"
 module EXEstage (
   input wire clk,
   input wire resetn,
@@ -21,54 +22,107 @@ module EXEstage (
   output reg es_block,
   input wire block,
   
-  input wire res_from_mul,
-  output reg exe_res_from_mul,
-  output [67:0] mul_result,
+  output wire [67:0] mul_result,
 
-  input wire ms_ex,
-  input wire wb_ex,
+  input wire ms_ex_to_es,
+  input wire es_reflush,
   output wire es_csr_re
 );
 
 
 //////////zip//////////
-wire [4:0]  load_op;
-wire [2:0]  store_op;
-wire [31:0] ds_pc;
-wire [31:0] alu_src1;
-wire [31:0] alu_src2;
-wire [15:0] alu_op;
-wire [2:0]  mul_op;
-wire [31:0] rkd_value;
-wire gr_we;
-wire [4:0] dest;
-wire [`EXCEPT_LEN-1 : 0] except_zip;
-assign {ds_pc, alu_src1, alu_src2, alu_op, mul_op,  load_op, store_op, rkd_value, gr_we, dest, except_zip} = ds2es_bus;
-reg [4:0] exe_dest;
-wire [31:0] alu_result;
-wire exe_rf_we;
-assign exe_forward_zip={exe_rf_we, exe_dest, alu_result};
-reg [31:0] es_pc;
-wire [4:0] exe_load_op;
-reg [15:0] alu_op_reg;
-reg [2:0]  mul_op_reg;
-reg exe_gr_we;
-reg [`EXCEPT_LEN-1 : 0] exe_except_zip;
-assign es2ms_bus = {es_pc, mul_op_reg, alu_result, exe_load_op, exe_dest, exe_gr_we,exe_except_zip};
+wire [4:0]  es_load_op;
+wire [2:0]  es_store_op;
+wire [31:0] es_pc;
+wire [31:0] es_alu_src1;
+wire [31:0] es_alu_src2;
+wire [15:0] es_alu_op;
+wire [2:0]  es_mul_op;
+wire [31:0] es_rkd_value;
+wire es_gr_we;
+wire [4:0]  es_dest;
+wire [`DS_EXC_DATA_WD-1 : 0] ds_exc_data;
+wire [1:0]  es_time_op;
+
+reg [`DS2ES_BUS_LEN-1 : 0] ds2es_bus_reg;
+
+wire [31:0] es_alu_result;
+wire [31:0] es_final_result;
+wire es_rf_we;
+assign exe_forward_zip={es_rf_we, es_dest,es_final_result};
 //////////declaration////////
 
 reg es_valid;
 
 wire        mem_we;
-reg [31:0] alu_src1_reg;
-reg [31:0] alu_src2_reg;
-
-reg [4:0]  load_op_reg;
-reg [2:0]  store_op_reg;
-reg [31:0] rkd_value_reg;
-
 wire alu_flag;
 
+wire        es_adef;
+wire [31:0] es_wrong_addr;
+wire        es_csr_we;
+wire [31:0] es_csr_wmask;
+wire [13:0] es_csr_num;
+wire        es_ertn_flush;
+wire        es_ex;
+wire        ds_ex;
+wire [ 8:0] es_esubcode;
+wire [31:0] ds_wrong_addr  ;
+wire [`ES_EXC_DATA_WD-1:0] es_exc_data;
+
+
+wire        ld_ale         ;
+wire        st_ale         ;
+wire        es_ale         ;
+wire [ 5:0] ds_ecode       ;
+wire [ 5:0] es_ecode       ;
+wire es_res_from_mul        ;
+assign {es_pc,es_res_from_mul, es_alu_src1, es_alu_src2, es_alu_op, es_mul_op,  es_load_op, es_store_op, es_rkd_value, es_gr_we, es_dest, ds_exc_data,es_time_op} = ds2es_bus_reg;
+assign es2ms_bus = {es_pc,es_res_from_mul,es_mul_op,es_final_result, es_load_op, es_dest, es_gr_we,es_rkd_value,es_exc_data};
+assign ld_ale  =  es_load_op[1] &es_alu_result[0]                        // inst_ld_h
+                | es_load_op[2] & (es_alu_result[1] |es_alu_result[0])   // inst_ld_w
+                | es_load_op[4] & es_alu_result[0] ;                      // inst_ld_hu
+assign st_ale  =  es_store_op[1] & es_alu_result[0]                       // inst_st_h
+                | es_store_op[2] & (es_alu_result[1] | es_alu_result[0]); // inst_st_w
+assign es_ale = ld_ale | st_ale;
+// counter read by rdcntvl.w and rdcntvh.w
+reg [63:0] counter;
+always @(posedge clk) begin
+    if (reset)
+        counter <= 64'b0;
+    else 
+        counter <= counter + 1'b1;
+end
+assign es_final_result  = {32{es_time_op[0]}}                 & counter[31: 0]
+                        | {32{es_time_op[1]}}                 & counter[63:32]
+                        | {32{~es_time_op[0]&~es_time_op[1]}} & es_alu_result;
+
+
+assign es_wrong_addr = es_adef ? ds_wrong_addr : es_alu_result;
+assign es_ecode   = es_ale ? `ECODE_ALE : ds_ecode;
+assign es_ex      = (ds_ex | es_ale) & es_valid;
+
+assign {es_adef,         // 98
+        ds_wrong_addr,   // 97:66
+        es_csr_re,       // 65
+        es_csr_we,       // 64
+        es_csr_wmask,    // 63:32
+        es_csr_num,      // 31:17
+        es_ertn_flush,   // 16
+        ds_ex,           // 15
+        es_esubcode,     // 14:6
+        ds_ecode         // 5:0
+        } = ds_exc_data;
+
+assign es_exc_data = {es_wrong_addr,         
+                     es_csr_we,                  
+                     es_csr_wmask,                        
+                     es_csr_num,                  
+                     es_ertn_flush,              
+                     es_ex,                       
+                     es_esubcode ,               
+                     es_ecode,
+                     es_csr_re                    
+                    };
 //////////pipeline////////
 wire es_ready_go;
 
@@ -81,25 +135,14 @@ always @(posedge clk) begin
   if (reset) begin
     es_valid <= 1'b0;
   end 
-  else if(wb_ex) begin
+  else if(es_reflush) begin
     es_valid <= 1'b0;
   end else if (es_allowin) begin
     es_valid <= ds2es_valid;
   end
   
   if(ds2es_valid && es_allowin)begin
-    es_pc <= ds_pc;
-    alu_src1_reg <= alu_src1;
-    alu_src2_reg <= alu_src2;
-    alu_op_reg   <= alu_op;
-    mul_op_reg  <=mul_op;
-    load_op_reg <= load_op;
-    store_op_reg <= store_op;
-    rkd_value_reg <= rkd_value;
-    exe_gr_we     <= gr_we;
-    exe_dest          <= dest;
-    exe_res_from_mul <= res_from_mul;
-    exe_except_zip <= except_zip;
+    ds2es_bus_reg <= ds2es_bus;
   end
 end
 
@@ -116,46 +159,41 @@ end
 //////////assign//////////
 
 
-assign es_csr_re = exe_except_zip[1];
-
-
-
 alu u_alu(
     .clk        (clk        ),
     .resetn     (resetn     ),
-    .alu_op     (alu_op_reg    ),
-    .alu_src1   (alu_src1_reg  ),
-    .alu_src2   (alu_src2_reg  ),
+    .alu_op     (es_alu_op    ),
+    .alu_src1   (es_alu_src1  ),
+    .alu_src2   (es_alu_src2  ),
     .alu_flag   (alu_flag),
-    .alu_result (alu_result)
+    .alu_result (es_alu_result)
     );
     
 wire [31:0] st_data;
 wire [3:0] st_strb;
 wire [3:0] st_sel;
 
-decoder_2_4 u_dec_st(.in(alu_result[1:0]), .out(st_sel));
+decoder_2_4 u_dec_st(.in(es_alu_result[1:0]), .out(st_sel));
 
-assign st_strb = {4{store_op_reg[0]}} &  st_sel
-               | {4{store_op_reg[1]}} & (st_sel[0] ? 4'b0011 : 4'b1100)
-               | {4{store_op_reg[2]}} &  4'b1111;
+assign st_strb = {4{es_store_op[0]}} &  st_sel
+               | {4{es_store_op[1]}} & (st_sel[0] ? 4'b0011 : 4'b1100)
+               | {4{es_store_op[2]}} &  4'b1111;
 
-assign st_data = {32{store_op_reg[0]}} & {4{rkd_value_reg[7:0]}}
-               | {32{store_op_reg[1]}} & {2{rkd_value_reg[15:0]}}
-               | {32{store_op_reg[2]}} & rkd_value_reg;
-assign mem_we=(|store_op_reg);
+assign st_data = {32{es_store_op[0]}} & {4{es_rkd_value[7:0]}}
+               | {32{es_store_op[1]}} & {2{es_rkd_value[15:0]}}
+               | {32{es_store_op[2]}} & es_rkd_value;
+assign mem_we=(|es_store_op);
 
-assign exe_rf_we = es_valid && exe_gr_we;
-assign exe_load_op =load_op_reg;
-assign data_sram_en    =  ((|exe_load_op)|mem_we) & es_valid;//1'b1;
-assign data_sram_we    =  {4{es_valid & ~wb_ex & ~ms_ex}} & mem_we ? st_strb : 4'b0;
-assign data_sram_addr  =  alu_result;
+assign es_rf_we = es_valid && es_gr_we;
+assign data_sram_en    =  ((|es_load_op)|mem_we) & es_valid;//1'b1;
+assign data_sram_we    =  {4{es_valid &  ~es_reflush & ~ms_ex_to_es & ~st_ale}} & mem_we ? st_strb : 4'b0;
+assign data_sram_addr  =  es_alu_result;
 assign data_sram_wdata =  st_data;
 //mul_src
 wire  [33:0]  mul_src1;
 wire  [33:0]  mul_src2;
-assign mul_src1 = {{2{alu_src1_reg[31] & ~mul_op_reg[2]}}, alu_src1_reg[31:0]};
-assign mul_src2 = {{2{alu_src2_reg[31] & ~mul_op_reg[2]}}, alu_src2_reg[31:0]};
+assign mul_src1 = {{2{es_alu_src1[31] & ~es_mul_op[2]}}, es_alu_src1[31:0]};
+assign mul_src2 = {{2{es_alu_src2[31] & ~es_mul_op[2]}}, es_alu_src2[31:0]};
 
 booth_multiplier u_mul(
   .clk(clk),
diff --git a/IDstage.v b/IDstage.v
index 768d099..b413238 100644
--- a/IDstage.v
+++ b/IDstage.v
@@ -1,4 +1,5 @@
 `include "BUS_LEN.vh"
+`include"CSR.vh"
 module IDstage (
   input wire clk,
   input wire reset,
@@ -9,23 +10,20 @@ module IDstage (
   output wire ds2es_valid,
   //branch  control signals
   output wire [`BR_BUS-1:0] br_zip,
-  input wire [`WB_RF_BUS-1:0] rf_zip,
   output wire[`DS2ES_BUS_LEN-1:0] ds2es_bus,
   input wire [`FS2DS_BUS_LEN-1:0] fs2ds_bus,
-
-  input wire [37:0] exe_forward_zip,
-  input wire [37:0] mem_forward_zip,
-    
+  //forward data
+  input wire [`FORWARD_BUS_LEN-1:0] exe_forward_zip,
+  input wire [`FORWARD_BUS_LEN-1:0] mem_forward_zip,
+  input wire [`WB_RF_BUS-1:0] rf_zip,
   input wire es_block,
   output wire block,
-  
-  output wire res_from_mul,
-  
-  input wire ms_ex,
-  input wire wb_ex,
-  
+
   input wire es_csr_re,
-  input wire ms_csr_re
+  input wire ms_csr_re,
+
+  input wire ds_reflush,
+  input wire ds_has_int
 );
 
 //////////zip//////////
@@ -33,26 +31,28 @@ wire br_taken;
 wire [31:0] br_target;
 assign br_zip = {br_taken, br_target};
 
+//forward data from exe,mem,wb
 wire rf_we;
 wire [4:0] rf_waddr;
 wire [31:0] rf_wdata;
 assign {rf_we, rf_waddr, rf_wdata} = rf_zip;
-
 wire exe_rf_we;
 wire mem_rf_we;
 wire [4:0] exe_dest;
 wire [4:0] mem_dest;
 wire [31:0] alu_result;
 wire [31:0] final_result;
-
 assign {exe_rf_we, exe_dest, alu_result}   = exe_forward_zip;
 assign {mem_rf_we, mem_dest, final_result} = mem_forward_zip;
 
-wire [31:0] fs_pc;
-wire [31:0] inst;
-assign {fs_pc, inst} = fs2ds_bus;
+//exception data from fs
+wire [`FS_EXC_DATA_WD-1:0]fs_exc_data;
+wire [31:0] ds_inst;
+wire [31:0] ds_pc;
+wire [31:0] ds_wrong_addr;
+wire        ds_adef     ;
+assign {ds_adef, ds_wrong_addr} = fs_exc_data;
 
-reg  [31:0] ds_pc;
 wire [31:0] alu_src1;
 wire [31:0] alu_src2;
 wire [15:0] alu_op;
@@ -62,30 +62,21 @@ wire [31:0] rkd_value;
 wire gr_we;
 wire [4:0] dest;
 wire mem_we;
-wire [`EXCEPT_LEN-1 : 0] ds_except_zip;
 wire [4:0] load_op;
 wire [2:0] store_op;
-assign ds2es_bus = {ds_pc, alu_src1, alu_src2, alu_op, mul_op, load_op, store_op, rkd_value, gr_we, dest, ds_except_zip/*82bits*/};
+wire res_from_mul;
+assign ds2es_bus = {ds_pc,res_from_mul, alu_src1, alu_src2, alu_op, mul_op, load_op, store_op, rkd_value, gr_we, dest, ds_exc_data/*98bits*/,time_op};
 
 //////////declaration////////
 reg ds_valid;
 
-
-// wire        br_taken;
-// wire [31:0] br_target;
-
-// wire [11:0] alu_op;
-//wire [4:0] load_op;
-//wire [2:0] store_op;
 wire src1_is_pc;
 wire src2_is_imm;
 wire dst_is_r1;
-// wire        gr_we;
-// wire        mem_we;
+wire dst_is_rj;
 wire src_reg_is_rd;
-// wire [4: 0] dest;
 wire [31:0] rj_value;
-// wire [31:0] rkd_value;
+
 wire rj_eq_rd;
 wire rj_lt_rd;
 wire rj_ltu_rd;
@@ -167,7 +158,11 @@ wire inst_csrwr;
 wire inst_csrxchg;
 wire inst_ertn;
 wire inst_syscall;
-
+//exp 13
+wire        inst_break;
+wire        inst_rdcntvl;
+wire        inst_rdcntvh;
+wire        inst_rdcntid;
 
 wire need_ui5;
 wire need_ui12;
@@ -182,66 +177,71 @@ wire [31:0] rf_rdata1;
 wire [ 4:0] rf_raddr2;
 wire [31:0] rf_rdata2;
 
-reg [31:0] inst_reg;
-
-wire csr_re;
-wire csr_we;
-wire [31:0] csr_wmask;
+//exp12 & exp13
+wire ds_csr_re;
+wire ds_csr_we;
+wire [31:0] ds_csr_wmask;
 wire [31:0] csr_wvalue;
-wire [13:0] csr_num;
-
+wire [13:0] ds_csr_num;
+wire [ 8:0] ds_esubcode  ;
+wire [ 5:0] ds_ecode     ;
+wire [`DS_EXC_DATA_WD-1:0] ds_exc_data  ;  
+wire [ 1:0] time_op      ;
 
 //////////pipeline//////////
+reg [`FS2DS_BUS_LEN-1: 0] fs2ds_bus_reg;
+always @(posedge clk) begin
+    if (reset || br_taken || ds_reflush) begin
+      ds_valid <= 1'b0;
+    end else if (ds_allowin) begin
+      ds_valid <= fs2ds_valid;
+    end
+
+    if(fs2ds_valid && ds_allowin)begin
+      fs2ds_bus_reg <= fs2ds_bus;
+    end
+  end
+assign {fs_exc_data,ds_pc,ds_inst}=fs2ds_bus_reg;
 
 wire ds_ready_go;
 wire exe_conflict_rj;
 wire exe_conflict_rkd;
 wire mem_conflict_rj;
 wire mem_conflict_rkd;
+wire ws_conflict_rj;
+wire ws_conflict_rkd;
 wire branch;
 
 assign branch = inst_beq | inst_bne | inst_blt | inst_bge | inst_bltu | inst_bgeu;
-assign exe_conflict_rj  = exe_dest == rf_raddr1 && |rf_raddr1 && (~src1_is_pc  & ~inst_lu12i_w & (|alu_op) | (|mul_op) | csr_re | branch);
-assign exe_conflict_rkd = exe_dest == rf_raddr2 && |rf_raddr2 && (~src2_is_imm &                 (|alu_op) | (|mul_op) | csr_re | branch);
-assign mem_conflict_rj  = mem_dest == rf_raddr1 && |rf_raddr1 && (~src1_is_pc  & ~inst_lu12i_w & (|alu_op) | (|mul_op) | csr_re | branch);
-assign mem_conflict_rkd = mem_dest == rf_raddr2 && |rf_raddr2 && (~src2_is_imm &                 (|alu_op) | (|mul_op) | csr_re | branch);
+assign exe_conflict_rj  = exe_dest == rf_raddr1 && |rf_raddr1 && (~src1_is_pc  & ~inst_lu12i_w & (|alu_op) | (|mul_op) | ds_csr_re | branch);
+assign exe_conflict_rkd = exe_dest == rf_raddr2 && |rf_raddr2 && (~src2_is_imm &                 (|alu_op) | (|mul_op) | ds_csr_re | branch);
+assign mem_conflict_rj  = mem_dest == rf_raddr1 && |rf_raddr1 && (~src1_is_pc  & ~inst_lu12i_w & (|alu_op) | (|mul_op) | ds_csr_re | branch);
+assign mem_conflict_rkd = mem_dest == rf_raddr2 && |rf_raddr2 && (~src2_is_imm &                 (|alu_op) | (|mul_op) | ds_csr_re | branch);
+assign ws_conflict_rj  =  rf_waddr == rf_raddr1 && |rf_raddr1 && (~src1_is_pc  & ~inst_lu12i_w & (|alu_op) | (|mul_op) | ds_csr_re | branch);
+assign ws_conflict_rkd =  rf_waddr == rf_raddr2 && |rf_raddr2 && (~src2_is_imm &                 (|alu_op) | (|mul_op) | ds_csr_re | branch);
 
-assign ds_ready_go    = ~(      exe_rf_we && (es_block | es_csr_re) && (exe_conflict_rj || exe_conflict_rkd)    ||
-                                mem_rf_we && (ms_csr_re)            && (mem_conflict_rj || mem_conflict_rkd)        );
+assign ds_ready_go    = ~(      exe_rf_we && (es_block | es_csr_re) && (exe_conflict_rj || exe_conflict_rkd)     ||
+                                mem_rf_we && (ms_csr_re)            && (mem_conflict_rj || mem_conflict_rkd)     ) ||ds_reflush;
 
 
 assign ds_allowin = ~ds_valid || ds_ready_go && es_allowin;
-assign ds2es_valid = ds_valid && ds_ready_go;
-
-always @(posedge clk) begin
-  if (reset || br_taken || wb_ex) begin
-    ds_valid <= 1'b0;
-  end else if (ds_allowin) begin
-    ds_valid <= fs2ds_valid;
-  end
-
-  if(fs2ds_valid && ds_allowin)begin
-    ds_pc <= fs_pc;
-    inst_reg <= inst;
-  end
-end
-
+assign ds2es_valid = ds_valid && ds_ready_go && ~ds_reflush;
 
 
 
-assign op_31_26  = inst_reg[31:26];
-assign op_25_22  = inst_reg[25:22];
-assign op_21_20  = inst_reg[21:20];
-assign op_19_15  = inst_reg[19:15];
+assign op_31_26  = ds_inst[31:26];
+assign op_25_22  = ds_inst[25:22];
+assign op_21_20  = ds_inst[21:20];
+assign op_19_15  = ds_inst[19:15];
 
-assign rd   = inst_reg[ 4: 0];
-assign rj   = inst_reg[ 9: 5];
-assign rk   = inst_reg[14:10];
+assign rd   = ds_inst[ 4: 0];
+assign rj   = ds_inst[ 9: 5];
+assign rk   = ds_inst[14:10];
 
-assign i12  = inst_reg[21:10];
-assign i20  = inst_reg[24: 5];
-assign i16  = inst_reg[25:10];
-assign i26  = {inst_reg[ 9: 0], inst_reg[25:10]};
+assign i12  = ds_inst[21:10];
+assign i20  = ds_inst[24: 5];
+assign i16  = ds_inst[25:10];
+assign i26  = {ds_inst[ 9: 0], ds_inst[25:10]};
 
 decoder_6_64 u_dec0(.in(op_31_26 ), .out(op_31_26_d ));
 decoder_4_16 u_dec1(.in(op_25_22 ), .out(op_25_22_d ));
@@ -267,10 +267,10 @@ assign inst_b      = op_31_26_d[6'h14];
 assign inst_bl     = op_31_26_d[6'h15];
 assign inst_beq    = op_31_26_d[6'h16];
 assign inst_bne    = op_31_26_d[6'h17];
-assign inst_lu12i_w= op_31_26_d[6'h05] & ~inst_reg[25];
+assign inst_lu12i_w= op_31_26_d[6'h05] & ~ds_inst[25];
 
 //additional instruction!
-assign inst_pcaddu12i = op_31_26_d[6'h07] & ~inst_reg[25];
+assign inst_pcaddu12i = op_31_26_d[6'h07] & ~ds_inst[25];
 
 //shift inst
 assign inst_sll_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0e];
@@ -303,7 +303,7 @@ assign inst_ld_bu  = op_31_26_d[6'h0a] & op_25_22_d[4'h8];
 assign inst_ld_hu  = op_31_26_d[6'h0a] & op_25_22_d[4'h9];
 assign inst_st_b   = op_31_26_d[6'h0a] & op_25_22_d[4'h4];
 assign inst_st_h   = op_31_26_d[6'h0a] & op_25_22_d[4'h5];
-
+//ä¾‹å¤–æŒ‡ä»¤
 assign inst_csrrd   = op_31_26_d[6'h01] & (op_25_22[3:2] == 2'b0) & (rj == 5'h00);
 assign inst_csrwr   = op_31_26_d[6'h01] & (op_25_22[3:2] == 2'b0) & (rj == 5'h01);
 assign inst_csrxchg = op_31_26_d[6'h01] & (op_25_22[3:2] == 2'b0) & ~inst_csrrd & ~inst_csrwr;
@@ -311,6 +311,12 @@ assign inst_ertn    = op_31_26_d[6'h01] & op_25_22_d[4'h9] & op_21_20_d[2'h0] &
                     & (rk == 5'h0e) & (~|rj) & (~|rd);
 assign inst_syscall = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h16];
 
+//exp 13
+assign inst_break   = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h14];
+assign inst_rdcntid = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h0] & op_19_15_d[5'h00] & (rk == 5'h18) & (rd == 5'h00);
+assign inst_rdcntvl = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h0] & op_19_15_d[5'h00] & (rk == 5'h18) & (rj == 5'h00);
+assign inst_rdcntvh = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h0] & op_19_15_d[5'h00] & (rk == 5'h19) & (rj == 5'h00);
+
 assign load_op[0] = inst_ld_b;
 assign load_op[1] = inst_ld_h;
 assign load_op[2] = inst_ld_w;
@@ -341,6 +347,8 @@ assign alu_op[15] = inst_mod_wu;
 assign mul_op[0] = inst_mul_w;
 assign mul_op[1] = inst_mulh_w;
 assign mul_op[2] = inst_mulh_wu;
+//exp13
+assign time_op = {inst_rdcntvh, inst_rdcntvl}; 
 
 assign need_ui5   =  inst_slli_w | inst_srli_w | inst_srai_w;
 assign need_ui12  =  inst_andi | inst_ori | inst_xori;
@@ -360,7 +368,7 @@ assign br_offs = {32{need_si26}} & {{ 4{i26[25]}}, i26[25:0], 2'b0} |
 
 assign jirl_offs = {{14{i16[15]}}, i16[15:0], 2'b0};    
 
-assign src_reg_is_rd = inst_beq | inst_bne | inst_blt | inst_bge | inst_bltu | inst_bgeu | (|store_op ) | csr_re;
+assign src_reg_is_rd = inst_beq | inst_bne | inst_blt | inst_bge | inst_bltu | inst_bgeu | (|store_op ) | ds_csr_re;
 
 assign src1_is_pc    = inst_jirl | inst_bl | inst_pcaddu12i;
 
@@ -381,11 +389,14 @@ assign src2_is_imm   = inst_slli_w |
                        inst_sltui;
 
 assign dst_is_r1     = inst_bl;
+assign dst_is_rj     = inst_rdcntid;
 assign gr_we         = ~inst_st_w & ~inst_st_h & ~inst_st_b & ~inst_beq  & 
                        ~inst_bne  & ~inst_b    & ~inst_bge  & ~inst_bgeu & 
                        ~inst_blt  & ~inst_bltu & ~inst_syscall & ~inst_ertn;
 assign mem_we        = inst_st_w | inst_st_b | inst_st_h;
-assign dest          = dst_is_r1 ? 5'd1 : rd;
+assign dest          = {5{dst_is_r1}} & 5'd1 
+                     | {5{dst_is_rj}} & rj 
+                     | {5{~dst_is_r1&~dst_is_rj}} & rd;
 
 
 assign res_from_mul = inst_mul_w || inst_mulh_w || inst_mulh_wu;
@@ -406,14 +417,14 @@ regfile u_regfile(
 //assign rj_value  = rf_rdata1;
 //assign rkd_value = rf_rdata2;
 assign rj_value = 
-    (exe_rf_we && exe_dest == rf_raddr1)? alu_result :
-    (mem_rf_we && mem_dest == rf_raddr1)? final_result :
-    (rf_we  &&    rf_waddr   == rf_raddr1)? rf_wdata   :
+    (exe_rf_we && exe_dest == rf_raddr1 && |rf_raddr1)? alu_result :
+    (mem_rf_we && mem_dest == rf_raddr1 && |rf_raddr1)? final_result :
+    (rf_we     && rf_waddr == rf_raddr1 && |rf_raddr1)? rf_wdata   :
     rf_rdata1;
 assign rkd_value = 
-    (exe_rf_we && exe_dest == rf_raddr2)? alu_result :
-    (mem_rf_we && mem_dest == rf_raddr2)? final_result :
-    (rf_we     && rf_waddr == rf_raddr2)?  rf_wdata   :
+    (exe_rf_we && exe_dest == rf_raddr2 && |rf_raddr2)? alu_result :
+    (mem_rf_we && mem_dest == rf_raddr2 && |rf_raddr2)? final_result :
+    (rf_we     && rf_waddr == rf_raddr2 && |rf_raddr2)?  rf_wdata   :
     rf_rdata2;
 
 assign {cout, cout_test} = {1'b0, rj_value} + {1'b0, ~rkd_value} + 1'b1;
@@ -440,13 +451,35 @@ assign alu_src2 = src2_is_imm ? imm : rkd_value;
 
 assign block = (|load_op) || res_from_mul;
 
-
-assign csr_re    = inst_csrrd | inst_csrwr | inst_csrxchg;
-assign csr_we    = inst_csrwr | inst_csrxchg;
-assign csr_wmask    = {32{inst_csrxchg}} & rj_value | {32{inst_csrwr}};
+assign ds_ine = ~ ( inst_add_w     | inst_sub_w   | inst_slt     | inst_sltu      |
+                 inst_nor       | inst_and     | inst_or      | inst_xor       |   
+                 inst_slli_w    | inst_srli_w  | inst_srai_w  | inst_addi_w    | 
+                 inst_ld_w      | inst_st_w    | inst_jirl    | inst_b         |
+                 inst_bl        | inst_beq     | inst_bne     | inst_lu12i_w   |
+                 inst_slti      | inst_sltui   | inst_andi    | inst_ori       | 
+                 inst_xori      | inst_sll_w   | inst_srl_w   | inst_sra_w     |
+                 inst_mul_w     | inst_mulh_w  | inst_mulh_wu | inst_div_w     | 
+                 inst_mod_w     | inst_div_wu  | inst_mod_wu  | inst_pcaddu12i |
+                 inst_blt       | inst_bge     | inst_bltu    | inst_bgeu      | 
+                 inst_ld_b      | inst_ld_h    | inst_ld_bu   | inst_ld_hu     |
+                 inst_st_b      | inst_st_h    | inst_csrrd   | inst_csrwr     |
+                 inst_csrxchg   | inst_ertn    | inst_syscall | inst_break     |
+                 inst_rdcntvl   | inst_rdcntvh | inst_rdcntid );
+assign ds_csr_re    = inst_csrrd | inst_csrwr | inst_csrxchg |inst_rdcntid;//è¯»ä½¿èƒ½ä¿¡å?
+assign ds_csr_we    = inst_csrwr | inst_csrxchg;//å†™ä½¿èƒ½ä¿¡å?
+assign ds_csr_wmask    = {32{inst_csrxchg}} & rj_value | {32{inst_csrwr}};
 assign csr_wvalue   = rkd_value;
-assign csr_num   = inst_reg[23:10];
-
-assign ds_except_zip  = {csr_num, csr_wmask, csr_wvalue, inst_syscall, inst_ertn, csr_re, csr_we};
+assign ds_csr_num   = {14{inst_rdcntid}} & `CSR_TID | {14{~inst_rdcntid}} & ds_inst[23:10];
+
+assign ds_ertn_flush = ds_valid & inst_ertn;
+assign ds_ex = ds_valid & (inst_syscall | inst_break | ds_ine | ds_has_int | ds_adef);
+
+assign ds_ecode = ds_has_int   ? `ECODE_INT
+                : ds_adef      ? `ECODE_ADE
+                : ds_ine       ? `ECODE_INE
+                : inst_break   ? `ECODE_BRK
+                : inst_syscall ? `ECODE_SYS : 6'b0;
+assign ds_esubcode = ds_adef ? `ESUBCODE_ADEF : 9'b0;
+assign ds_exc_data = {ds_adef, ds_wrong_addr, ds_csr_re,ds_csr_we, ds_csr_wmask,ds_csr_num, ds_ertn_flush, ds_ex, ds_esubcode, ds_ecode};
 
 endmodule
\ No newline at end of file
diff --git a/IFstage.v b/IFstage.v
index b1a7e40..e39d71e 100644
--- a/IFstage.v
+++ b/IFstage.v
@@ -1,23 +1,25 @@
 `include "BUS_LEN.vh"
 module IFstage (
-  input  wire clk,
-  input  wire resetn,
+  input  wire                       clk,
+  input  wire                       resetn,
   //the interface with the SRAM
-  output wire inst_sram_en,
-  output wire [3:0] inst_sram_we,
-  output wire [31:0] inst_sram_addr,
-  output wire [31:0] inst_sram_wdata,
-  input  wire [31:0] inst_sram_rdata,
+  output wire                       inst_sram_en,
+  output wire [3:0]                 inst_sram_we,
+  output wire [31:0]                inst_sram_addr,
+  output wire [31:0]                inst_sram_wdata,
+  input  wire [31:0]                inst_sram_rdata,
   //the interface between the IFstage and the IDstage  
-  input  wire [`BR_BUS-1:0] br_zip,
-  output wire [`FS2DS_BUS_LEN-1:0] fs2ds_bus,
-  input  wire ds_allowin,
-  output wire fs2ds_valid,
-
+  input  wire [`BR_BUS-1:0]         br_zip,
+  output wire [`FS2DS_BUS_LEN-1:0]  fs2ds_bus,
+  input  wire                       ds_allowin,
+  output wire                       fs2ds_valid,
+  //ws to fs csr data
   input wire wb_ex,
   input wire ertn_flush,
-  input wire [31:0] ex_entry,
-  input wire [31:0] ertn_entry
+  input wire [31: 0] csr_ex_entry,
+  input wire [31: 0] csr_ertn_entry,
+
+  input wire fs_reflush
 );
 
 
@@ -32,22 +34,25 @@ wire [31:0] br_target;
 wire [31:0] fs_pc;
 wire [31:0] inst;
 
-
+//exp13
+wire        fs_adef;
+wire [31:0] fs_wrong_addr;
+wire [`FS_EXC_DATA_WD-1:0] fs_exc_data;
 //////////zip//////////
 assign {br_taken, br_target} = br_zip;
-assign fs2ds_bus = {fs_pc, inst};
-
+assign fs2ds_bus = {fs_exc_data,    //95:64
+                    fs_pc,          //63:32
+                    inst};          //31:0
 
 //////////pipeline////////
 wire fs_ready_go; 
 wire fs_allowin; 
 reg fs_valid;
 
-assign fs_ready_go = 1'b1;
-assign fs_allowin = ~fs_valid || fs_ready_go && ds_allowin || ertn_flush || wb_ex;
-assign fs2ds_valid = fs_valid && fs_ready_go;
-
 assign fs_pc = pc;
+assign fs_ready_go = 1'b1;
+assign fs_allowin = ~fs_valid || fs_ready_go && ds_allowin;
+assign fs2ds_valid = fs_valid && fs_ready_go && ~fs_reflush;
 
 always @(posedge clk) begin
   if (~resetn) begin
@@ -56,7 +61,7 @@ always @(posedge clk) begin
   else if (fs_allowin) begin
     fs_valid <= resetn;
   end
-  
+
   if (~resetn) begin
     pc <= 32'h1bfffffc; // trick: to make nextpc be 0x1c000000 during reset
   end 
@@ -65,11 +70,17 @@ always @(posedge clk) begin
   end
 end
 
-//////////assign//////////
+// adef: address error
+assign fs_adef = nextpc[1] | nextpc[0];
+assign fs_wrong_addr = nextpc;
+assign fs_exc_data    = {fs_valid & fs_adef, // 32:32
+                         fs_wrong_addr       // 31:0
+                        };
 
+//////////assign//////////
 assign seq_pc = pc + 3'h4;
-assign nextpc  =  wb_ex? ex_entry:
-                  ertn_flush? ertn_entry:
+assign nextpc  =  wb_ex? csr_ex_entry:
+                  ertn_flush? csr_ertn_entry:
                   br_taken ? br_target : seq_pc;
 
 assign inst_sram_en = resetn && fs_allowin;
diff --git a/MEMstage.v b/MEMstage.v
index 5bc9df6..70842c0 100644
--- a/MEMstage.v
+++ b/MEMstage.v
@@ -14,64 +14,52 @@ module MEMstage (
   output wire [`MS2WS_BUS_LEN-1:0] ms2ws_bus,
   output wire [`FORWARD_BUS_LEN-1:0] mem_forward_zip,
   
-  input wire exe_res_from_mul,
   input [67:0] mul_result,
 
-  output wire ms_ex,
-  input wire wb_ex,
+  output wire ms_ex_to_es,
+  input wire ms_reflush,
   output wire ms_csr_re
 );
 
 
 //////////zip//////////
-wire [31:0] es_pc;
-wire [31:0] alu_result;
-wire [4:0] exe_dest;
-wire [4:0]load_op;
-wire [2:0]mul_op;
-wire exe_gr_we;
-wire [`EXCEPT_LEN-1 : 0] except_zip;
-assign {es_pc, mul_op, alu_result, load_op, exe_dest, exe_gr_we ,except_zip} = es2ms_bus;
+wire [31:0] ms_pc;
+wire [31:0] mem_alu_result;
+wire [4:0]  mem_dest;
+wire [4:0]  mem_load_op;
+wire [2:0]  mem_mul_op;
+wire mem_gr_we;
+wire [31:0] mem_rkd_value;
+wire [`ES_EXC_DATA_WD-1 : 0] mem_exc_data;
+wire mem_res_from_mul;
+reg[`ES2MS_BUS_LEN-1:0] es2ms_bus_reg;
+assign {ms_pc,mem_res_from_mul,mem_mul_op, mem_alu_result, mem_load_op, mem_dest, mem_gr_we,mem_rkd_value,mem_exc_data} = es2ms_bus_reg;
 
 wire mem_rf_we;
-reg [4:0] mem_dest_reg;
-wire[4:0] mem_dest;
-wire [31:0] final_result;
-assign mem_dest=mem_dest_reg;
-assign mem_forward_zip = {mem_rf_we, mem_dest, final_result};
-
-reg [31:0] ms_pc;
-reg mem_gr_we;
-reg [`EXCEPT_LEN-1 : 0] mem_except_zip;
-assign ms2ws_bus = {ms_pc, mem_gr_we, mem_dest, final_result, mem_except_zip};
+wire [31:0] mem_final_result;
+assign mem_forward_zip = {mem_rf_we, mem_dest, mem_final_result};
+
+assign ms2ws_bus = {ms_pc, mem_gr_we, mem_dest, mem_final_result, mem_rkd_value,mem_exc_data};
 //////////declaration//////////
 
-reg [18:0] mem_alu_op;
-reg [31:0] mem_alu_result;
-reg [ 4:0] mem_load_op;
-reg [ 2:0] mem_mul_op;
 wire mem_res_from_mem;
 wire [31:0]mem_result;
 wire [31:0]mem_mul_result;
-wire res_from_mul;
 
 reg ms_valid;
 
-reg res_from_mul_reg;
-
 //////////pipeline//////////
 wire ms_ready_go;
 
 assign ms_ready_go = 1'b1;
 assign ms_allowin = ~ms_valid || ms_ready_go && ws_allowin;
-assign ms2ws_valid = ms_valid && ms_ready_go;
-assign ms_ex = mem_except_zip[3] | mem_except_zip[2]; 
+assign ms2ws_valid = ms_valid && ms_ready_go && ~ms_reflush;
 
 always @(posedge clk) begin
   if (reset) begin
     ms_valid <= 1'b0;
   end 
-  if (wb_ex) begin
+  if (ms_reflush) begin
     ms_valid <= 1'b0;
   end
   else if (ms_allowin) begin
@@ -79,21 +67,38 @@ always @(posedge clk) begin
   end
  
   if(es2ms_valid && ms_allowin)begin
-    ms_pc <= es_pc;
-    mem_alu_result <= alu_result;
-    mem_load_op <= load_op;
-    mem_mul_op  <= mul_op;
-    mem_dest_reg <= exe_dest;
-    mem_gr_we <= exe_gr_we;
-    res_from_mul_reg <= exe_res_from_mul;
-    mem_except_zip <= except_zip;
+    es2ms_bus_reg <= es2ms_bus;
   end
 end
 
 
-assign ms_csr_re = mem_except_zip[1];
+assign ms_csr_re = mem_exc_data[0];
+
+assign ms_ex_to_es = (mem_ertn_flush | mem_ex) & ms_valid;
+
+// exception
+wire mem_csr_re;
+wire mem_csr_we;
+wire [31:0] mem_wrong_addr;
+wire [13:0] mem_csr_num   ;
+wire [31:0] mem_csr_wmask ;
+wire        mem_ertn_flush;
+wire        mem_ex        ;
+wire [ 8:0] mem_esubcode  ;
+wire [ 5:0] mem_ecode     ;
+
+assign {mem_wrong_addr,    
+        mem_csr_we,
+        mem_csr_wmask,        
+        mem_csr_num,       
+        mem_ertn_flush,    
+        mem_ex,            
+        mem_esubcode,      
+        mem_ecode,
+        mem_csr_re         
+      } = mem_exc_data;
+assign ms_to_es_ex = (mem_ertn_flush | mem_ex) & ms_valid;
 
-assign ms_ex = mem_except_zip[3] | mem_except_zip[2];
 
 assign mem_rf_we = ms_valid && mem_gr_we;
 assign mem_res_from_mem = (|mem_load_op);
@@ -117,13 +122,11 @@ assign lh_data = {32{ld_sel[0]}} & {{16{mem_result[15] & zero_ext}}, mem_result[
 assign ld_data = {32{mem_load_op[0] | mem_load_op[3]}} & lb_data
                | {32{mem_load_op[1] | mem_load_op[4]}} & lh_data
                | {32{mem_load_op[2]}} & mem_result;
-
 assign mem_result     =   data_sram_rdata;
 assign mem_mul_result =   ({32{mem_mul_op[0]               }} & mul_result[31: 0])
                         | ({32{mem_mul_op[1]  | mem_mul_op[2]}} & mul_result[63:32]);
-assign res_from_mul=res_from_mul_reg;
                     
-assign final_result   = {32{mem_res_from_mem}} & ld_data | 
-                        {32{res_from_mul}} & mem_mul_result |
-                        {32{~mem_res_from_mem &~res_from_mul}}&mem_alu_result ;
+assign mem_final_result  = {32{mem_res_from_mem}} & ld_data | 
+                        {32{mem_res_from_mul}} & mem_mul_result |
+                        {32{~mem_res_from_mem &~mem_res_from_mul}}&mem_alu_result ;
 endmodule
diff --git a/WBstage.v b/WBstage.v
index 052bc96..0830027 100644
--- a/WBstage.v
+++ b/WBstage.v
@@ -16,9 +16,10 @@ module WBstage (
   output wire [4:0] debug_wb_rf_wnum,
   output wire [31:0] debug_wb_rf_wdata,
   
-  output wire ertn_flush,
-  output wire wb_ex,
-  input  wire [31:0] csr_rvalue
+  output wire ws_ertn_flush,
+  output wire ws_ex,
+  input  wire [31:0] csr_rvalue,
+  output wire ws_reflush
 );
 
 //////////zip//////////
@@ -27,33 +28,35 @@ wire [4:0] rf_waddr;
 wire [31:0] rf_wdata;
 assign rf_zip = {rf_we, rf_waddr, rf_wdata};
 
-wire [31:0] ms_pc;
-wire mem_gr_we;
-wire [4:0] mem_dest;
-reg  [4:0] dest_reg;
-wire [31:0] final_result;
-wire [`EXCEPT_LEN-1 : 0] except_zip;
-assign {ms_pc, mem_gr_we, mem_dest, final_result, except_zip} = ms2ws_bus;
+wire [31:0] ws_pc;
+wire ws_gr_we;
+wire [4:0] ws_dest;
+wire [31:0] ws_final_result;
+wire [`MS_EXC_DATA_WD -1 : 0] ws_exc_data;
 
-wire csr_re;
-wire csr_we;
-wire [13:0] csr_num;
-wire [31:0] csr_wmask;
-wire [31:0] csr_wvalue;
-reg  [31:0] ws_pc;
-wire [ 5:0] wb_ecode;
-wire [ 8:0] wb_esubcode;
-assign ws2csr_bus = {csr_re, csr_we, csr_num, csr_wmask, csr_wvalue, ws_pc, wb_ecode, wb_esubcode};
+reg  [`MS2WS_BUS_LEN -1 : 0] ms2ws_bus_reg;
 
+
+wire ws_csr_re;
+wire ws_csr_we;
+wire [13:0] ws_csr_num;
+wire [31:0] ws_csr_wmask;
+wire [31:0] ws_csr_wvalue;
+wire [ 5:0] ws_ecode;
+wire [ 8:0] ws_esubcode;
+wire [31: 0]ws_wrong_addr;
+wire [31: 0]ws_rkd_value;
+// exp13
+wire  [ 7:0] ws_hw_int_in  = 8'b0 ;
+wire         ws_ipi_int_in = 1'b0 ;
+wire  [31:0] ws_coreid_in  = 32'b0;
+assign ws2csr_bus = {ws_csr_re, ws_csr_we, ws_csr_num, ws_csr_wmask, ws_csr_wvalue, ws_pc, ws_ecode, ws_esubcode,ws_ipi_int_in,ws_coreid_in,ws_hw_int_in,ws_wrong_addr};
+assign {ws_pc, ws_gr_we, ws_dest, ws_final_result,ws_rkd_value, ws_exc_data} = ms2ws_bus_reg;
 //////////declaration////////
 reg ws_valid;
-reg [31:0] final_result_reg;
-reg gr_we_reg;
-reg [`EXCEPT_LEN-1 : 0] wb_except_zip;
 //////////pipeline//////////
 wire ws_ready_go;
 
-
 assign ws_ready_go = 1'b1;
 assign ws_allowin = ~ws_valid || ws_ready_go;
 
@@ -61,7 +64,7 @@ always @(posedge clk) begin
   if (reset) begin
     ws_valid <= 1'b0;
   end 
-  else if (wb_ex | ertn_flush) begin
+  else if (ws_ex | ws_ertn_flush) begin
     ws_valid <= 1'b0;
   end
   else if (ws_allowin) begin
@@ -69,25 +72,33 @@ always @(posedge clk) begin
   end
   
   if(ms2ws_valid && ws_allowin)begin
-    ws_pc <= ms_pc;
-    gr_we_reg <= mem_gr_we;
-    dest_reg <= mem_dest;
-    final_result_reg <= final_result;
-    wb_except_zip <= except_zip;
+    ms2ws_bus_reg <= ms2ws_bus;
   end
 end
 
-assign {csr_num, csr_wmask, csr_wvalue, wb_ex, ertn_flush, csr_re, csr_we} = wb_except_zip & {82{ws_valid}};    // wb_ex=inst_syscall, ertn_flush=inst_ertn
-assign wb_ecode = {6{wb_ex}} & 6'hb;
-assign wb_esubcode = 9'b0;
+assign {ws_wrong_addr,    
+        ws_csr_we,
+        ws_csr_wmask,        
+        ws_csr_num,       
+        ws_ertn_flush,  
+        ws_ex,           
+        ws_esubcode,     
+        ws_ecode,
+        ws_csr_re       
+      }  = ws_exc_data & {`MS_EXC_DATA_WD {ws_valid}};    // wb_ex=inst_syscall, ertn_flush=inst_ertn
+assign ws_csr_wvalue = ws_rkd_value;
+
+
+assign ws_reflush = ws_ertn_flush | ws_ex;
+
 //////////assign//////////
-assign rf_we = gr_we_reg && ws_valid;
-assign rf_waddr = dest_reg;
-assign rf_wdata = csr_re ? csr_rvalue : final_result_reg;
+assign rf_we = ws_gr_we && ws_valid && ~ws_ex;
+assign rf_waddr = ws_dest;
+assign rf_wdata = ws_csr_re ? csr_rvalue : ws_final_result;
 
 assign debug_wb_pc = ws_pc;
 assign debug_wb_rf_we = {4{rf_we}};
-assign debug_wb_rf_wnum = dest_reg;
-assign debug_wb_rf_wdata = csr_re ? csr_rvalue : final_result_reg;
+assign debug_wb_rf_wnum = ws_dest;
+assign debug_wb_rf_wdata = ws_csr_re ? csr_rvalue : ws_final_result;
 
 endmodule
diff --git a/csr.v b/csr.v
index 2ebae64..daecab3 100644
--- a/csr.v
+++ b/csr.v
@@ -1,4 +1,4 @@
-`include "BUS_LEN.vh"
+`include "CSR.vh"
 module csr(
     input  wire          clk       ,
     input  wire          reset     ,
@@ -8,64 +8,99 @@ module csr(
     output wire [31:0]   ertn_entry,
 
     input  wire          ertn_flush,
+
     input  wire          wb_ex     ,
-    input wire [`WS2CSR_BUS_LEN-1 : 0] ws2csr_bus
+    input  wire [`WS2CSR_BUS_LEN-1 : 0] ws2csr_bus,
+    //exp13
+    output wire          has_int
 );
-    
+    //ws2csr_bus
     wire csr_re;
     wire csr_we;
     wire [13:0] csr_num;
     wire [31:0] csr_wmask;
     wire [31:0] csr_wvalue;
-    wire  [31:0] ws_pc;
+    wire  [31:0] wb_pc;
     wire [ 5:0] wb_ecode;
     wire [ 8:0] wb_esubcode;
-    assign {csr_re, csr_we, csr_num, csr_wmask, csr_wvalue, ws_pc, wb_ecode, wb_esubcode} = ws2csr_bus;
-
-
+    wire ipi_int_in;
+    wire [31:0] coreid_in;
+    wire [ 7:0] hw_int_in;
+    wire [31:0] wb_vaddr;
+    assign {csr_re, csr_we, csr_num, csr_wmask, csr_wvalue, wb_pc, wb_ecode, wb_esubcode, ipi_int_in, coreid_in, hw_int_in, wb_vaddr} = ws2csr_bus;
 
-    // å½“å‰æ¨¡å¼ä¿¡æ¯
-    wire [31: 0] csr_crmd_data;
-    reg  [ 1: 0] csr_crmd_plv;      //CRMDçš„PLVåŸŸï¼Œå½“å‰ç‰¹æƒç­‰çº§
-    reg          csr_crmd_ie;       //CRMDçš„å…¨å±?ä¸­æ–­ä½¿èƒ½ä¿¡å·
-    reg          csr_crmd_da;       //CRMDçš„ç›´æŽ¥åœ°å?ç¿»è¯‘ä½¿èƒ½
+    // CRMD
+    wire [31: 0] csr_crmd_rvalue;
+    reg  [ 1: 0] csr_crmd_plv;      //CRMD's PLV domain, current privilege level
+    reg          csr_crmd_ie;       //CRMD's global interrupt enable signal
+    reg          csr_crmd_da;       //CRMD's direct address translation enable signal
     reg          csr_crmd_pg;
     reg  [ 6: 5] csr_crmd_datf;
     reg  [ 8: 7] csr_crmd_datm;
 
-    // ä¾‹å¤–å‰æ¨¡å¼ä¿¡æ?
-    wire [31: 0] csr_prmd_data;
-    reg  [ 1: 0] csr_prmd_pplv;     //CRMDçš„PLVåŸŸæ—§å€?
-    reg          csr_prmd_pie;      //CRMDçš„IEåŸŸæ—§å€?
+    // PRMD
+    wire [31: 0] csr_prmd_rvalue;
+    reg  [ 1: 0] csr_prmd_pplv;     //Old value of CRMD's PLV field
+    reg          csr_prmd_pie;      //Old value of CRMD's PIE field
 
-    // ä¾‹å¤–çŠ¶æ??
-    wire [31: 0] csr_estat_data;    // ä¿ç•™ä½?15:13, 31
-    reg  [12: 0] csr_estat_is;      // ä¾‹å¤–ä¸­æ–­çš„çŠ¶æ€ä½ï¼?8ä¸ªç¡¬ä»¶ä¸­æ–?+1ä¸ªå®šæ—¶å™¨ä¸­æ–­+1ä¸ªæ ¸é—´ä¸­æ–?+2ä¸ªè½¯ä»¶ä¸­æ–­ï¼‰
-    reg  [ 5: 0] csr_estat_ecode;   // ä¾‹å¤–ç±»åž‹ä¸?çº§ç¼–ç ?
-    reg  [ 8: 0] csr_estat_esubcode;// ä¾‹å¤–ç±»åž‹äºŒçº§ç¼–ç 
+    // ESTAT
+    wire [31: 0] csr_estat_rvalue;    
+    reg  [12: 0] csr_estat_is;      // Status bits for exception interrupts, 8 hardware interrupts + 1 timer interrupt + 1 inter-core interrupt + 2 software interrupts)
+    reg  [ 5: 0] csr_estat_ecode;   // Exception type level-1 code
+    reg  [ 8: 0] csr_estat_esubcode;// Exception type level-2 code
 
-    // ä¾‹å¤–è¿”å›žåœ°å€ERA
-    reg  [31: 0] csr_era_data;  // data
+    // ERA
+    reg  [31: 0] csr_era_data;  
+    wire [31: 0] csr_era_rvalue;
 
-    // ä¾‹å¤–å…¥å£åœ°å€eentry
-    wire [31: 0] csr_eentry_data;   // ä¿ç•™ä½?5:0
-    reg  [25: 0] csr_eentry_va;     // ä¾‹å¤–ä¸­æ–­å…¥å£é«˜ä½åœ°å€
-    // å‡ºé”™è™šåœ°å?
+    // EENTRY
+    wire [31: 0] csr_eentry_rvalue;   
+    reg  [25: 0] csr_eentry_va;     // Exception Interrupt Entry High Address
+    
+    // SAVE0-3
     reg  [31: 0] csr_save0_data;
     reg  [31: 0] csr_save1_data;
     reg  [31: 0] csr_save2_data;
     reg  [31: 0] csr_save3_data;
+    wire [31:0] csr_save0_rvalue;
+    wire [31:0] csr_save1_rvalue;
+    wire [31:0] csr_save2_rvalue;
+    wire [31:0] csr_save3_rvalue;
 
-    assign ex_entry = csr_eentry_data;
-    assign ertn_entry = csr_era_data;
+    assign ex_entry = csr_eentry_rvalue;
+    assign ertn_entry = csr_era_rvalue;
 
+    // ECFG
+    reg [12:0] csr_ecfg_lie;
+    wire [31:0] csr_ecfg_rvalue;
+    
+    // BADV
+    wire wb_ex_addr_err;
+    reg [31:0] csr_badv_vaddr;
+    wire [31:0] csr_badv_rvalue;
 
+    // TID 
+    reg [31:0] csr_tid_tid ;
+    wire [31:0] csr_tid_rvalue;
 
+    // TCFG
+    reg csr_tcfg_en ; 
+    reg csr_tcfg_periodic ;
+    reg [29:0] csr_tcfg_initval ;
+    wire [31:0] csr_tcfg_rvalue ;
 
+    // TVAL
+    wire [31:0] tcfg_next_value ;
+    reg  [31:0] timer_cnt ;
+    wire [31:0] csr_tval_timeval;
+    wire [31:0] csr_tval_rvalue ;
 
+    // TICLR
+    wire csr_ticlr_clr ;
+    wire [31:0] csr_ticlr_rvalue ;
 
 
-    // CRMDçš„PLVã€IEåŸŸï¼šè€ƒè™‘å¤ä½ã€ä¾‹å¤–ã?ä¾‹å¤–è¿”å›žå’Œå†?
+    // CRMD's PLVã€IE field
     always @(posedge clk) begin
         if (reset) begin
             csr_crmd_plv <= 2'b0;
@@ -87,7 +122,7 @@ module csr(
         end
     end
 
-    // CRMDçš„DAã€PGã€DATFã€DATMåŸŸï¼šè€ƒè™‘å¤ä½å’Œå†™
+    // DA, PG, DATF, DATM domains of CRMD: consider reset and write
     always @(posedge clk) begin
         if(reset) begin
             csr_crmd_da   <= 1'b1;
@@ -103,7 +138,7 @@ module csr(
         end
     end
 
-    // PRMDçš„PPLVã€PIEåŸŸï¼šè€ƒè™‘ä¾‹å¤–å’Œå†™
+    // PPLV, PIE domains for PRMD: considering exceptions and writes
     always @(posedge clk) begin
         if (wb_ex) begin
             csr_prmd_pplv <= csr_crmd_plv;
@@ -117,7 +152,7 @@ module csr(
         end
     end
 
-    // ESTATçš„ISåŸŸï¼šè€ƒè™‘å¤ä½å’Œå†™
+    // The IS domain of ESTAT: considering resets and writes
     always @(posedge clk) begin
         if (reset) begin
             csr_estat_is[1:0] <= 2'b0;
@@ -129,11 +164,17 @@ module csr(
 
         csr_estat_is[9:2] <= 8'b0;
         csr_estat_is[ 10] <= 1'b0;
-        csr_estat_is[ 11] <= 1'b0;
-        csr_estat_is[ 12] <= 1'b0;
+        //exp13
+        if (csr_tcfg_en && timer_cnt[31:0] == 32'b0)
+            csr_estat_is[11] <= 1'b1;
+        else if (csr_we && csr_num == `CSR_TICLR 
+                        && csr_wmask[`CSR_TICLR_CLR] 
+                        && csr_wvalue[`CSR_TICLR_CLR]) 
+            csr_estat_is[11] <= 1'b0;              
+            csr_estat_is[12] <= ipi_int_in;
     end    
 
-    // ESTATçš„Ecodeå’ŒEsubCodeåŸŸï¼šåªè?ƒè™‘ä¾‹å¤–
+    // ESTAT's Ecode and EsubCode domains: considering only the exceptions
     always @(posedge clk) begin
         if (wb_ex) begin
             csr_estat_ecode    <= wb_ecode;
@@ -141,23 +182,23 @@ module csr(
         end
     end
 
-    // ERAçš„PCåŸŸï¼šè€ƒè™‘ä¾‹å¤–å’Œå†™
+    // ERA's PC domain: considering exceptions and writes
     always @(posedge clk) begin
         if(wb_ex)
-            csr_era_data <= ws_pc;
+            csr_era_data <= wb_pc;
         else if (csr_we && csr_num == `CSR_ERA) 
             csr_era_data <= csr_wmask[`CSR_ERA_PC] & csr_wvalue[`CSR_ERA_PC]
-                        | ~csr_wmask[`CSR_ERA_PC] & csr_era_data;
+                        | ~csr_wmask[`CSR_ERA_PC] & csr_era_rvalue;
     end
 
-     // EENTRYï¼šåªè€ƒè™‘å†?
+     // EENTRY
     always @(posedge clk) begin
         if (csr_we && (csr_num == `CSR_EENTRY))
             csr_eentry_va <=   csr_wmask[`CSR_EENTRY_VA] & csr_wvalue[`CSR_EENTRY_VA]
                             | ~csr_wmask[`CSR_EENTRY_VA] & csr_eentry_va ;
     end
 
-    // SAVE0~3ï¼šåªè€ƒè™‘å†?
+    // SAVE0~3
     always @(posedge clk) begin
         if (csr_we && csr_num == `CSR_SAVE0) 
             csr_save0_data <=  csr_wmask[`CSR_SAVE_DATA] & csr_wvalue[`CSR_SAVE_DATA]
@@ -173,24 +214,106 @@ module csr(
                             | ~csr_wmask[`CSR_SAVE_DATA] & csr_save3_data;
     end
 
+    //exp13
+    // ECFG
+    always @(posedge clk) begin
+        if(reset)
+            csr_ecfg_lie <= 13'b0;
+        else if(csr_we && csr_num == `CSR_ECFG)
+            csr_ecfg_lie <= csr_wmask[`CSR_ECFG_LIE] & csr_wvalue[`CSR_ECFG_LIE]
+                        | ~csr_wmask[`CSR_ECFG_LIE] & csr_ecfg_lie;
+    end
 
+    // BADV
+    assign wb_ex_addr_err = wb_ecode==`ECODE_ADE || wb_ecode==`ECODE_ALE;
+    always @(posedge clk) begin
+        if (wb_ex && wb_ex_addr_err)
+            csr_badv_vaddr <= (wb_ecode == `ECODE_ADE && 
+                               wb_esubcode == `ESUBCODE_ADEF) ? wb_pc : wb_vaddr;
+    end
 
+    // TID
+    always @(posedge clk) begin
+        if (reset)
+            csr_tid_tid <= coreid_in;
+        else if (csr_we && csr_num==`CSR_TID)
+            csr_tid_tid <= csr_wmask[`CSR_TID_TID] & csr_wvalue[`CSR_TID_TID]
+                        | ~csr_wmask[`CSR_TID_TID] & csr_tid_tid;
+    end
 
+    // TCFG
+    always @(posedge clk) begin
+        if (reset)
+            csr_tcfg_en <= 1'b0;
+        else if (csr_we && csr_num==`CSR_TCFG)
+            csr_tcfg_en <= csr_wmask[`CSR_TCFG_EN] & csr_wvalue[`CSR_TCFG_EN] 
+                        | ~csr_wmask[`CSR_TCFG_EN] & csr_tcfg_en;
+
+        if (csr_we && csr_num==`CSR_TCFG) begin
+            csr_tcfg_periodic <= csr_wmask[`CSR_TCFG_PERIOD] & csr_wvalue[`CSR_TCFG_PERIOD]
+                              | ~csr_wmask[`CSR_TCFG_PERIOD] & csr_tcfg_periodic;
+            csr_tcfg_initval  <= csr_wmask[`CSR_TCFG_INITV] & csr_wvalue[`CSR_TCFG_INITV]
+                              | ~csr_wmask[`CSR_TCFG_INITV] & csr_tcfg_initval;
+        end
+    end
+
+    // TVAL
+    assign tcfg_next_value =  csr_wmask[31:0] & csr_wvalue[31:0]
+                            | ~csr_wmask[31:0] & {csr_tcfg_initval, csr_tcfg_periodic, csr_tcfg_en};
+
+    always @(posedge clk) begin
+        if (reset)
+            timer_cnt <= 32'hffffffff;
+        else if (csr_we && csr_num == `CSR_TCFG && tcfg_next_value[`CSR_TCFG_EN])
+            timer_cnt <= {tcfg_next_value[`CSR_TCFG_INITV], 2'b0};
+        else if (csr_tcfg_en && timer_cnt != 32'hffffffff) begin
+            if (timer_cnt[31:0] == 32'b0 && csr_tcfg_periodic)
+                timer_cnt <= {csr_tcfg_initval, 2'b0};
+            else
+                timer_cnt <= timer_cnt - 1'b1;
+        end
+    end
+    assign csr_tval_timeval = timer_cnt[31:0];
+
+    // TICLR
+    assign csr_ticlr_clr = 1'b0;
 
-    // CSRè¯»æŒ‡ä»¤çš„è¯»å‡ºæ•°æ®ï¼šç”¨åŸŸé‡æ–°æ‹¼æŽ¥æˆå®Œæ•´çš„å¯„å­˜å™¨å†…å®¹ï¼Œé?šè¿‡å¯„å­˜å™¨å·é€‰æ‹©è¯»å›žçš„æ•°æ?
-    assign csr_crmd_data  = {23'b0, csr_crmd_datm, csr_crmd_datf, csr_crmd_pg, 
-                            csr_crmd_da, csr_crmd_ie, csr_crmd_plv};
-    assign csr_prmd_data  = {29'b0, csr_prmd_pie, csr_prmd_pplv};
-    assign csr_estat_data = { 1'b0, csr_estat_esubcode, csr_estat_ecode, 3'b0, csr_estat_is};
-    assign csr_eentry_data= {csr_eentry_va, 6'b0};
 
-    assign csr_rvalue = {32{csr_num == `CSR_CRMD  }} & csr_crmd_data
-                      | {32{csr_num == `CSR_PRMD  }} & csr_prmd_data
-                      | {32{csr_num == `CSR_ESTAT }} & csr_estat_data
-                      | {32{csr_num == `CSR_ERA   }} & csr_era_data
-                      | {32{csr_num == `CSR_EENTRY}} & csr_eentry_data
-                      | {32{csr_num == `CSR_SAVE0 }} & csr_save0_data
-                      | {32{csr_num == `CSR_SAVE1 }} & csr_save1_data
-                      | {32{csr_num == `CSR_SAVE2 }} & csr_save2_data
-                      | {32{csr_num == `CSR_SAVE3 }} & csr_save3_data;
+    // Readout data for CSR read instructions: re-spliced with fields to complete register contents, read back data selected by register number
+    assign csr_crmd_rvalue   = {23'b0, csr_crmd_datm, csr_crmd_datf, csr_crmd_pg, 
+                                csr_crmd_da, csr_crmd_ie, csr_crmd_plv};
+    assign csr_prmd_rvalue   = {29'b0, csr_prmd_pie, csr_prmd_pplv};
+    assign csr_estat_rvalue  = {1'b0, csr_estat_esubcode, csr_estat_ecode, 3'b0, csr_estat_is};
+    assign csr_eentry_rvalue = {csr_eentry_va, 6'b0};
+    assign csr_era_rvalue    =  csr_era_data;  
+    assign csr_save0_rvalue  =  csr_save0_data;
+    assign csr_save1_rvalue  =  csr_save1_data;
+    assign csr_save2_rvalue  =  csr_save2_data;
+    assign csr_save3_rvalue  =  csr_save3_data;
+    
+    //exp13
+    assign csr_ecfg_rvalue   =  {19'b0, csr_ecfg_lie[12:11],1'b0,csr_ecfg_lie[9:0]};
+    assign csr_badv_rvalue   =  csr_badv_vaddr;
+    assign csr_tid_rvalue    =  csr_tid_tid ;
+    assign csr_tcfg_rvalue   =  {csr_tcfg_initval, csr_tcfg_periodic, csr_tcfg_en};
+    assign csr_tval_rvalue   =  csr_tval_timeval;
+    assign csr_ticlr_rvalue  =  {31'b0, csr_ticlr_clr};
+
+    assign csr_rvalue = {32{csr_num == `CSR_CRMD  }} & csr_crmd_rvalue
+                      | {32{csr_num == `CSR_PRMD  }} & csr_prmd_rvalue
+                      | {32{csr_num == `CSR_ESTAT }} & csr_estat_rvalue
+                      | {32{csr_num == `CSR_ERA   }} & csr_era_rvalue
+                      | {32{csr_num == `CSR_EENTRY}} & csr_eentry_rvalue
+                      | {32{csr_num == `CSR_SAVE0 }} & csr_save0_rvalue
+                      | {32{csr_num == `CSR_SAVE1 }} & csr_save1_rvalue
+                      | {32{csr_num == `CSR_SAVE2 }} & csr_save2_rvalue
+                      | {32{csr_num == `CSR_SAVE3 }} & csr_save3_rvalue
+                      | {32{csr_num == `CSR_ECFG  }} & csr_ecfg_rvalue
+                      | {32{csr_num == `CSR_BADV  }} & csr_badv_rvalue
+                      | {32{csr_num == `CSR_TID   }} & csr_tid_rvalue
+                      | {32{csr_num == `CSR_TCFG  }} & csr_tcfg_rvalue
+                      | {32{csr_num == `CSR_TVAL  }} & csr_tval_rvalue
+                      | {32{csr_num == `CSR_TICLR }} & csr_ticlr_rvalue;
+    
+    assign has_int = ((csr_estat_is[11:0] & csr_ecfg_lie[11:0]) != 12'b0) && (csr_crmd_ie == 1'b1);
 endmodule
\ No newline at end of file
diff --git a/div.v b/div.v
index 53e3e9e..a765714 100644
--- a/div.v
+++ b/div.v
@@ -51,7 +51,7 @@ module DIV(
         end
     end
 
-    assign pre_r = remainder_reg - dividend_pad;                  
+    assign pre_r =  remainder_reg - dividend_pad;                  
     assign recover_r = pre_r[32] ? remainder_reg : pre_r;    
     always @(posedge clk) begin
         if(~resetn) 
@@ -70,7 +70,9 @@ module DIV(
                 remainder_reg <=  (counter[5]&(~|counter[4:0])) ? recover_r : {recover_r, divisor_pad[31 - counter]};
         end
     end
+    
     assign quotient = sign & sign_s ? (~quotient_reg+1'b1) : quotient_reg;
     assign remainder = sign & sign_r ? (~remainder_reg+1'b1) : remainder_reg;
-    assign result ={quotient,remainder};
+    
+    assign result = (|divisor) ? {quotient,remainder} :{32'b0,remainder }; 
 endmodule
\ No newline at end of file
diff --git a/mycpu_top.v b/mycpu_top.v
index 4bb08bf..b5b6641 100644
--- a/mycpu_top.v
+++ b/mycpu_top.v
@@ -4,7 +4,7 @@ module mycpu_top (
   input  wire        resetn,
   // inst sram interface
   output wire        inst_sram_en,
-  output wire [3:0] inst_sram_we,
+  output wire [3:0]  inst_sram_we,
   output wire [31:0] inst_sram_addr,
   output wire [31:0] inst_sram_wdata,
   input  wire [31:0] inst_sram_rdata,
@@ -21,20 +21,9 @@ module mycpu_top (
   output wire [31:0] debug_wb_rf_wdata
 );
 
-// reg         reset;
 reg         reset;
 always @(posedge clk) reset <= ~resetn;
 
-//reg         valid;
-//always @(posedge clk) begin
-//    if (~resetn) begin
-//        valid <= 1'b0;
-//    end
-//    else begin
-//        valid <= 1'b1;
-//    end
-//end
-
 
 //wire fs_allowin;
 wire ds_allowin;
@@ -48,16 +37,12 @@ wire ms2ws_valid;
 
 wire [`FORWARD_BUS_LEN-1:0] exe_forward_zip;
 wire [`FORWARD_BUS_LEN-1:0] mem_forward_zip;
+wire [`BR_BUS-1:0] br_zip;
+wire [`WB_RF_BUS-1:0] rf_zip;
 
-
-wire res_from_mul;
-wire exe_res_from_mul;
 wire es_block;
 wire block;
 
-wire [`BR_BUS-1:0] br_zip;
-wire [`WB_RF_BUS-1:0] rf_zip;
-
 wire [`FS2DS_BUS_LEN-1:0]   fs2ds_bus;
 wire [`DS2ES_BUS_LEN-1:0]   ds2es_bus;
 wire [`ES2MS_BUS_LEN-1:0]   es2ms_bus;
@@ -66,23 +51,23 @@ wire [`WS2CSR_BUS_LEN-1 : 0] ws2csr_bus;
 
 wire [67:0] mul_result;
 
-wire [31:0] csr_rvalue;
-wire [31:0] ex_entry;
-wire [31:0] ertn_entry;
+wire [31:0] csr_ex_entry;
+wire [31:0] csr_ertn_entry;
+wire [31:0]csr_rvalue;
 wire        ertn_flush;
 wire        ms_ex;
 wire        wb_ex;
 
 wire ms_csr_re;
 wire es_csr_re;
-
+wire ds_has_int;
+wire ws_reflush;
+wire ms_ex_to_es;
+wire csr_has_int;
 IFstage my_if (
   .clk              (clk),
   .resetn           (resetn),
   
-  .ds_allowin       (ds_allowin),
-  .fs2ds_valid      (fs2ds_valid),
-  
   .inst_sram_en     (inst_sram_en),
   .inst_sram_we     (inst_sram_we),
   .inst_sram_addr   (inst_sram_addr),
@@ -91,11 +76,15 @@ IFstage my_if (
   
   .br_zip           (br_zip),
   .fs2ds_bus        (fs2ds_bus),
-
-  .ex_entry         (ex_entry  ),
-  .ertn_entry       (ertn_entry),
+  .ds_allowin       (ds_allowin),
+  .fs2ds_valid      (fs2ds_valid),
+  
+  .csr_ex_entry     (csr_ex_entry  ),
+  .csr_ertn_entry   (csr_ertn_entry),
   .ertn_flush       (ertn_flush),
-  .wb_ex            (wb_ex     )
+  .wb_ex            (wb_ex     ),
+
+  .fs_reflush       (ws_reflush)
 );
 
 IDstage my_id (
@@ -109,20 +98,19 @@ IDstage my_id (
 
   .br_zip           (br_zip),
   .ds2es_bus        (ds2es_bus),
-  .rf_zip           (rf_zip),
   .fs2ds_bus        (fs2ds_bus),
 
   .mem_forward_zip  (mem_forward_zip),
   .exe_forward_zip  (exe_forward_zip),
-  
-  .res_from_mul     (res_from_mul),
+  .rf_zip           (rf_zip),
+
   .es_block         (es_block),
   .block            (block),
 
-  .ms_ex            (ms_ex),
-  .wb_ex            (wb_ex | ertn_flush),
   .ms_csr_re        (ms_csr_re),
-  .es_csr_re        (es_csr_re)
+  .es_csr_re        (es_csr_re),
+  .ds_has_int       (csr_has_int),
+  .ds_reflush       (ws_reflush)
 );
 
 EXEstage my_exe (
@@ -145,15 +133,14 @@ EXEstage my_exe (
 
   .exe_forward_zip  (exe_forward_zip),
 
-  .res_from_mul     (res_from_mul),
-  .exe_res_from_mul (exe_res_from_mul),
   .es_block         (es_block),
   .block            (block),
+
   .mul_result       (mul_result),
 
-  .ms_ex            (ms_ex),
-  .wb_ex            (wb_ex | ertn_flush),
-  .es_csr_re        (es_csr_re)
+  .ms_ex_to_es      (ms_ex_to_es),
+  .es_csr_re        (es_csr_re),
+  .es_reflush       (ws_reflush)
 );
 
 MEMstage my_mem (
@@ -169,13 +156,12 @@ MEMstage my_mem (
   
   .es2ms_bus        (es2ms_bus),
   .ms2ws_bus        (ms2ws_bus),
-  
-  .exe_res_from_mul (exe_res_from_mul),
   .mem_forward_zip  (mem_forward_zip),
+
   .mul_result       (mul_result),
 
-  .ms_ex            (ms_ex),
-  .wb_ex            (wb_ex | ertn_flush),
+  .ms_ex_to_es      (ms_ex_to_es),
+  .ms_reflush       (ws_reflush),
   .ms_csr_re        (ms_csr_re)
 );
 
@@ -196,8 +182,9 @@ WBstage my_wb (
   .debug_wb_rf_wdata(debug_wb_rf_wdata),
 
   .csr_rvalue       (csr_rvalue),
-  .ertn_flush       (ertn_flush),
-  .wb_ex            (wb_ex),
+  .ws_ertn_flush       (ertn_flush),
+  .ws_reflush       (ws_reflush),
+  .ws_ex            (wb_ex),
   .ws2csr_bus       (ws2csr_bus)
 );
 
@@ -205,11 +192,12 @@ WBstage my_wb (
     .clk            (clk       ),
     .reset          (reset   ),
     .csr_rvalue     (csr_rvalue),
-    .ex_entry       (ex_entry  ),
-    .ertn_entry     (ertn_entry),
+    .ex_entry       (csr_ex_entry  ),
+    .ertn_entry     (csr_ertn_entry),
     .ertn_flush     (ertn_flush),
     .wb_ex          (wb_ex     ),
-    .ws2csr_bus     (ws2csr_bus)
+    .ws2csr_bus     (ws2csr_bus),
+    .has_int        (csr_has_int) 
     );
 
 endmodule
\ No newline at end of file
